--- CODE CELL 1 ---
!pip install pandas-datareader

--- CODE CELL 2 ---
import pandas as pd 
import pandas_datareader as web
import numpy as np
import matplotlib.pyplot as plt 
import statsmodels.api as sm
%matplotlib inline 

--- CODE CELL 3 ---
#Adj Price
df = web.get_data_yahoo('META', start = '2020-01-01', end='2020-12-31')['Adj Close']
df

--- CODE CELL 4 ---
#Adj return 
ret = df.pct_change()
ret = ret.dropna()
ret

--- CODE CELL 5 ---
# log price 

log_price = np.log(df)
log_price

--- CODE CELL 6 ---
# log return 

log_return = log_price.shift(-1) - log_price
log_return = log_return.dropna()
log_return

--- CODE CELL 7 ---
# V = E[log return] = E[lnSt-lnSt-1]

V = log_return.mean() # t변화량 = 하루 

# std = std[log return]

std = np.sqrt(log_return.var()) # t변화량 = 하루 

print(V)
print(std)

--- CODE CELL 8 ---
# t변화량 - 하루 

t_change = 1 

# 100일 예측 

t_value = np.arange(1, 101, 1) #start, stop, step 
t_value

--- CODE CELL 9 ---
# 0~1 값부여 -> 정규분포 cdf의 inverse 값들로부여 

import scipy as sp
import scipy.stats

rv = sp.stats.norm()

xx = np.linspace(-8, 8, 100)
cdf = rv.cdf(xx)
plt.plot(xx, cdf)

--- CODE CELL 10 ---
Epsilon = np.random.choice(cdf, size=t_value.shape)

--- CODE CELL 11 ---
# Epsilon 여러개 생성 

Epsilon_list = [] 

for i in range(10000): 
    Eps = np.random.standard_normal(t_value.shape[0])
    Epsilon_list.append(Eps)

Epsilon_list[0].shape

--- CODE CELL 12 ---
# 난수값 부여 log_return 

log_return_senario_list = [] 
price_return_senario_list = []

for Eps in Epsilon_list:
    log_return_senario = V*t_change + std*Eps*np.sqrt(t_change)
    log_return_senario = pd.Series(log_return_senario, index= t_value)
    log_return_senario_list.append(log_return_senario)
    
    price_return_senario = np.exp(log_return_senario) - 1 
    price_return_senario_list.append(price_return_senario)
    
    


--- CODE CELL 13 ---
log_return_senario_list[0]  # v+s*Error

--- CODE CELL 14 ---
price_return_senario_list[0] # e^(v+s*Error)

--- CODE CELL 15 ---
# 10000개 시나리오 return들의 expected return, standarad deviation of return 구하기 

price_expected_return_list= []
price_risk_list = []
log_expected_return_list =[]
log_risk_list =[]
for price_return, log_return in zip(price_return_senario_list, log_return_senario_list):
    
    ann_price_return = price_return.mean() * 252
    ann_price_risk = np.sqrt(price_return.var() * 252)
    ann_log_return = log_return.mean() * 252
    ann_log_risk = np.sqrt(log_return.var() * 252)
    
    price_expected_return_list.append(ann_price_return)
    price_risk_list.append(ann_price_risk)
    log_expected_return_list.append(ann_log_return)
    log_risk_list.append(ann_log_risk)
    
    

--- CODE CELL 16 ---
# 구한 10000개 시나리오 return들의 expected return, standarad deviation of return 들의 percentile값들 구하기 


# price return, risk 오름차순 정렬 

price_expected_return_list.sort()
price_risk_list.sort()
log_expected_return_list.sort()
log_risk_list.sort()

# 하위 10% return,risk

lower_10_price_return = np.percentile(price_expected_return_list, 0.1)
lower_10_price_risk = np.percentile(price_risk_list, 0.1)
lower_10_log_return = np.percentile(log_expected_return_list, 0.1)
lower_10_log_risk = np.percentile(log_risk_list, 0.1)



# 중위 50% return,risk
middle_price_return = np.percentile(price_expected_return_list, 0.5)
middle_price_risk = np.percentile(price_risk_list, 0.5)
middle_log_return = np.percentile(log_expected_return_list, 0.5)
middle_log_risk = np.percentile(log_risk_list, 0.5)

# 상위 10% return,risk

upper_10_price_return = np.percentile(price_expected_return_list, 0.9)
upper_10_price_risk = np.percentile(price_risk_list, 0.9)
upper_10_log_return = np.percentile(log_expected_return_list, 0.9)
upper_10_log_risk = np.percentile(log_risk_list, 0.9)






print('price')
print('<return>')
print(lower_10_price_return, middle_price_return, upper_10_price_return)
print('<risk>')
print(lower_10_price_risk, middle_price_risk, upper_10_price_risk)
print('\n')

print("all senarios' price returns mean", np.mean(price_expected_return_list)) #이미 annaulized 되어있는 값들 -> 다시해줄필요없음 
print("all senarios' price returns std", np.sqrt(np.var(price_expected_return_list)))

print('\n')


print('log_price')
print('<return>')
print(lower_10_log_return, middle_log_return, upper_10_log_return)
print('<risk>')
print(lower_10_log_risk, middle_log_risk, upper_10_log_risk)

print('\n')


print("all senarios' log_price returns mean", np.mean(log_expected_return_list)) #이미 annaulized 되어있는 값들 -> 다시해줄필요없음 
print("all senarios' log_price returns std", np.sqrt(np.var(log_expected_return_list)))




--- CODE CELL 17 ---
import seaborn as sns
import scipy as sp 

sns.distplot(price_expected_return_list, kde=True, rug= True, fit=sp.stats.norm)
sns.distplot(log_expected_return_list, kde=True, rug= True, fit=sp.stats.norm)

sns.set(rc={'figure.figsize':(20,20)})





--- CODE CELL 18 ---
# skewness -price_return_senarios'

sp.stats.skew(price_expected_return_list), sp.stats.kurtosis(price_expected_return_list)

--- CODE CELL 19 ---
# skewness -log_return_senarios'

sp.stats.skew(log_expected_return_list), sp.stats.kurtosis(log_expected_return_list)

--- CODE CELL 20 ---
import seaborn as sns
import scipy as sp 

sns.distplot(price_risk_list, kde=True, rug= True, fit=sp.stats.norm)
sns.distplot(log_risk_list, kde=True, rug= True, fit=sp.stats.norm)

sns.set(rc={'figure.figsize':(20,20)})





--- CODE CELL 21 ---
# skewness - 각 price_return senario들의 std of return 들 

sp.stats.skew(price_risk_list), sp.stats.kurtosis(price_risk_list)

--- CODE CELL 22 ---
# skewness - 각 log_return senario들의 std of return 들 

sp.stats.skew(log_risk_list), sp.stats.kurtosis(log_risk_list)

--- CODE CELL 23 ---
# v+s*Error (dt=1) -> expected S1 = S0 * e^(v+s*Error)
# expected S2 = expected S2 + e^(v+s*Error)

# 보통 마지막 price를 S0으로 놓고 진행!!!! 

exp_return = np.exp(log_return_senario_list[0]) # e^(v+s*Error)
exp_return

--- CODE CELL 24 ---
# p_senario = df * np.exp(log_return_senario_list[0]) 잘못된 예시!! 

price_expected = []
price_expected.append(df[-1])

for i in range(len(exp_return)):
    price_expect = price_expected[i] * exp_return[i+1]
    price_expected.append(price_expect)

--- CODE CELL 25 ---
plt.plot(t_value, price_expected[:-1])

--- CODE CELL 26 ---
exp_return_list = []

for log_return_senario in log_return_senario_list:

    exp_return = np.exp(log_return_senario) # e^(v+s*Error)
    exp_return_list.append(exp_return)

--- CODE CELL 27 ---
price_expected_list = []

for exp_return in exp_return_list:
    price_expected = []
    price_expected.append(df[-1])

    for i in range(len(exp_return)):

        price_expect = price_expected[i] * exp_return[i+1]
        price_expected.append(price_expect)
    price_expected_list.append(price_expected)

--- CODE CELL 28 ---
for i in range(len(price_expected_list)):
    plt.plot(t_value, price_expected_list[i][:-1])

--- CODE CELL 29 ---
# T=100 시점이 option 만기일 
# T=100 시점 S(T)와 F(T)비교 

# S(0) * 1.5 = F(T)

Ft = df[-1] * 1.2 # S(0) = historical price 마지막
Opt_price = df[-1] * 0.1 #옵션사는비용 - 이번엔 고려 x  

option_return = []

for price_expect in price_expected_list:
    if price_expect[-1] > Ft : # S(T) > Ft 이면 optin 행사 
        opt_return = (price_expect[-1] - Ft)/ Ft 
    else:  # S(T) <= Ft 이면 optin 행사 x 
        opt_return = 0
    
    option_return.append(opt_return)

--- CODE CELL 30 ---
(np.array(option_return)==0).sum()

--- CODE CELL 31 ---
#Option 행사안한 비율 

print('option 행사한 개수: ', (np.array(option_return)==0).sum())
print('option 행사하지 않은 개수 : ', len(option_return)- (np.array(option_return)==0).sum())
print('option 행사비율: ', (np.array(option_return)==0).sum()/ len(option_return)) 

--- CODE CELL 32 ---
option_exe_return = np.array(option_return)[np.array(option_return)!=0]

--- CODE CELL 33 ---
import seaborn as sns
import scipy as sp 

sns.distplot(option_exe_return, kde=True, rug= True, fit=sp.stats.norm)
sns.set(rc={'figure.figsize':(20,20)})

--- CODE CELL 34 ---
print(np.mean(option_exe_return), np.sqrt(np.var(option_exe_return)))

--- CODE CELL 35 ---
# 향후 performance 진행할 수 있음 (MDD, CVaR, 다양한 Ratio 등)

